#ifndef SOPNET_CATMAID_SOLUTION_GUARANTOR_H__
#define SOPNET_CATMAID_SOLUTION_GUARANTOR_H__

#include <pipeline/SimpleProcessNode.h>
#include <sopnet/block/Cores.h>
#include <sopnet/slices/ConflictSets.h>
#include <sopnet/slices/Slices.h>
#include <sopnet/segments/Segments.h>
#include <catmaid/persistence/SegmentStore.h>
#include <catmaid/persistence/SliceStore.h>
#include <catmaid/persistence/StackStore.h>
#include <inference/LinearConstraint.h>
#include <inference/PriorCostFunctionParameters.h>
#include <inference/ProblemAssembler.h>
#include <inference/SegmentationCostFunctionParameters.h>



class SolutionGuarantor : public pipeline::SimpleProcessNode<> {

public:
	/**
	 * Construct a SolutionGuarantor
	 * 
	 * Inputs:
	 *   Cores                       "cores"
	 *   SegmentStore                "segment store"
	 *   SliceStore                  "slice store"
	 *   StackStore                  "raw image store"
	 *   StackStore                  "membrane image store"
	 *   unsigned int                "buffer" - optional
	 *   bool                        "force explanation" - optional
	 *   SegmentationCostFunctionParameters
	 *                               "segmentation cost parameters" - optional
	 *   PriorCostFunctionParameters "prior cost parameters" - optional
	 * 
	 * Outputs:
	 *   Blocks                       "need blocks"
	 * 
	 * "need blocks" is empty when the solution was guaranteed successfuly.
	 * 
	 * SolutionGuarantor is a ProcessNode that guarantees the existence of a solution over Segments
	 * in the SegmentStore. Here, a solution consists of both the per-Segment score generated by
	 * a LinearSolver as well as a selection flag generated by Reconstructor. The selection flag
	 * will ideally be independing of the Core, but this cannot be guaranteed, so it is stored
	 * core-wise.
	 * 
	 * A SolutionGuarantor will first check the requested geometry and its surround for an existing
	 * solution. If one already exists everywhere, then it will simply return.
	 * 
	 * Next, it will check for the existence of Slices, Segments, and image data in the requested
	 * geometry. If there exists a Block for which the required data has not already been
	 * extracted, it will be added to the "need blocks" output, and not solutions will be
	 * generated.
	 * 
	 * Otherwise, the SolutionGuarantor will proceed to guarantee the solutions, which will be
	 * placed in the SegmentStore.
	 */
	SolutionGuarantor();
	
	pipeline::Value<Blocks> guaranteeSolution();
	
private:
	/**
	 * Assembles segment-wise linear constraints from slices-wise conflict sets.
	 */
	class ConstraintAssembler : public pipeline::SimpleProcessNode<>
	{
	public:
		ConstraintAssembler();
		
	private:
		void updateOutputs();
		
		boost::shared_ptr<LinearConstraint> assembleConstraint(const ConflictSet& conflictSet,
						std::map<unsigned int, std::vector<unsigned int> >& sliceSegmentsMap);
		
		pipeline::Input<Segments> _segments;
		pipeline::Input<ConflictSets> _conflictSets;
		pipeline::Input<bool> _assemblerForceExplanation;
		
		pipeline::Output<LinearConstraints> _constraints;
	};
	
	/**
	 * Guarantees that we have correct EndSegments at the section representing the upper bound
	 * of our sub stack. The SegmentGuarantor wouldn't necessarily have extracted these.
	 */
	class EndExtractor : public pipeline::SimpleProcessNode<>
	{
	public:
		EndExtractor();
		
	private:
		void updateOutputs();
		
		pipeline::Input<Segments> _eeSegments;
		pipeline::Input<Slices> _eeSlices;
		
		pipeline::Output<Segments> _allSegments;
	};
	
	void updateOutputs();
	
	void setupInputs();
	
	bool checkData(const boost::shared_ptr<Blocks> solveBlocks,
				   pipeline::Value<Blocks> needBlocks);
	
	/**
	 * Finds the subset of the argument blocks that do not yet have solutions scores stored
	 * for their segments.
	 */
	boost::shared_ptr<Blocks> checkCost(const boost::shared_ptr<Blocks> blocks);
	
	void storeCosts(const boost::shared_ptr<Blocks> costBlocks);
	
	void solve(const boost::shared_ptr<Blocks> blocks);
	
	pipeline::Input<PriorCostFunctionParameters> _priorCostFunctionParameters;
	pipeline::Input<SegmentationCostFunctionParameters> _segmentationCostFunctionParameters;
	pipeline::Input<Cores> _cores;
	pipeline::Input<SegmentStore> _segmentStore;
	pipeline::Input<SliceStore> _sliceStore;
	pipeline::Input<StackStore> _rawImageStore;
	pipeline::Input<StackStore> _membraneStore;
	pipeline::Input<unsigned int> _bufferRadius;
	pipeline::Input<bool> _forceExplanation;
	
	bool _useForceExplanation;
	int _useBufferRadius;
	boost::shared_ptr<SegmentationCostFunctionParameters> _useSCFP;
	boost::shared_ptr<PriorCostFunctionParameters> _usePCFP;
	
	pipeline::Output<Blocks> _needBlocks;
};

#endif // SOPNET_CATMAID_SOLUTION_GUARANTOR_H__

