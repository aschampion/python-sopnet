#ifndef SEGMENT_STORE_H__
#define SEGMENT_STORE_H__

#include <boost/unordered_map.hpp>

#include <sopnet/segments/Segment.h>
#include <sopnet/segments/Segments.h>
#include <catmaid/blocks/Block.h>
#include <catmaid/blocks/Core.h>
#include <catmaid/blocks/Blocks.h>
#include <pipeline/Data.h>
#include <pipeline/Value.h>
#include <sopnet/features/Features.h>
#include <sopnet/inference/Solution.h>
#include <sopnet/inference/LinearObjective.h>
#include <catmaid/persistence/SegmentPointerHash.h>


/**
 * Abstract Data class that handles the practicalities of storing and retrieving Segments from a store.
 */
class SegmentStore : public pipeline::Data
{
public:
	typedef boost::unordered_map<boost::shared_ptr<Segment>,
								 std::vector<double>,
								 SegmentPointerHash,
								 SegmentPointerEquals> SegmentFeaturesMap;

	/**
	 * Write Segments over the given Blocks to this SegmentStore.
	 */
	void writeSegments(const Segments& segments, const Blocks& blocks);

    /**
     * Associates a segment with a block
     * @param segment - the segment to store.
     * @param block - the block containing the segment.
     */
    virtual void associate(pipeline::Value<Segments> segments,
						   pipeline::Value<Block> block) = 0;

    /**
     * Retrieve all segments that are at least partially contained in the given block.
     * @param block - the Block for which to retrieve all segments.
     */
    virtual pipeline::Value<Segments> retrieveSegments(const Blocks& blocks) = 0;

	/**
	 * Retrieve a set of Blocks that are associated with the given Segment.
	 * @param segment - the Segment for which to retrieve associated Blocks
	 */
	virtual pipeline::Value<Blocks> getAssociatedBlocks(pipeline::Value<Segment> segment) = 0;
	
	/**
	 * Store a set of Features associated to a set of Segments. Segments must be associated before
	 * Features may be associated with them.
	 * @param features - the Features to store
	 * @return the number of Segments for which Features were stored. For instance, if this is not
	 * equal to the size of features, then there were Segments for which Features were calculated
	 * but not stored. This may not necessarily be an error, however.
	 */
	virtual int storeFeatures(pipeline::Value<Features> features) = 0;

	/**
	 * Retrieve a set of Feautres associated to the set of given Segments.
	 * @param segments - the Segments for which to retrieve Features
	 * @return a map from a shared_ptr to a Segment to a vector of double values representing the
	 * features for that Segment.
	 * 
	 * Conversion to a Features object is handled in SegmentFeatureReader.
	 */
	virtual pipeline::Value<SegmentFeaturesMap>
		retrieveFeatures(pipeline::Value<Segments> segments) = 0;

	/**
	 * Retrieve the names of the Segment Features that have been stored herel.
	 */
	virtual std::vector<std::string> getFeatureNames() = 0;

	/**
	 * Store costs for the given segments.
	 * @param segments - the Segments corresponding to the given Solution object
	 * @param objective - the LinearObjective, which contains costs assigned by, for instance, a
	 * LinearCostFunction (as generated by the ObjectiveGenerator)
	 * @return the number of Segments for which the costs were successfully stored. This will
	 * be less than the size of segments when not all of the Segments have already been associated
	 * to a block in this store.
	 * 
	 * An Object object stores a linear index of scores on the Segments that were given to the
	 * solver. In other words, objective->getCoefficients[i] returns the score corresponding to
	 * segments->getSegments()[i], so it is important to input the same Segments object that was used
	 * for the ObjectiveGenerator.
	 */
	virtual unsigned int storeCost(pipeline::Value<Segments> segments,
							   pipeline::Value<LinearObjective> objective) = 0;

	/**
	 * Retrieve the costs for the given segments.
	 * @param segments - the Segments for which solution scores are to be retrieved.
	 * @param defaultCost - the cost to assign to segments for which there is no stored
	 * cost
	 * @param segmentsNF - an empty Segments object, into which any Segment that does not have
	 * a stored cost will be added.
	 * @return the corresponding LinearObjective object
	 * 
	 * The returned LinearObjective object will be indexed to correspond to the segments
	 * argument. Segments for which there is no cost stored in this SegmentStore will be
	 * assigned the defaultCost value. 
	 */
	virtual pipeline::Value<LinearObjective> retrieveCost(pipeline::Value<Segments> segments,
														  double defaultCost,
														  pipeline::Value<Segments> segmentsNF)= 0;

	/**
	 * Store the solution for a given set of Segments and a give Core.
	 * @param segments - the segments for which the Solution is to be stored
	 * @param core - the Core to which this segments-solution assignment is to be associated.
	 * @param solution - the solution to be assigned
	 * @param indices - a vector that maps indices from segments to solution
	 * @return the number of Segments for which a solution was successfully stored. This will
	 * be less than the size of segments when not all of the Segments have already been associated
	 * to a Block in the given Core.
	 * 
	 * A Solution is indexed linearly to a Segments object when it is created, but we usually
	 * will want to store solutions for a subset of given segments. The indices vector maps from
	 * indices in segments to indices in solution, in other words:
	 * let j = indices[i], then the ith segment maps to the jth value in solution
	 */
	virtual unsigned int storeSolution(pipeline::Value<Segments> segments,
									   pipeline::Value<Core> core,
									   pipeline::Value<Solution> solution,
									   std::vector<unsigned int> indices) = 0;

	/**
	 * Retrieve the solutions for the given segments, associated with the given Core.
	 * @param segments - the Segments for which solution scores are to be retrieved.
	 * @param core - the Core for which the solution was generated.
	 * @return the corresponding LinearObjective object
	 * 
	 * The returned Solution object will be indexed to correspond to the segments
	 * argument. Any Segments not associated to a Block in core, or without an associated solution
	 * value in the store will be assigned a solution value of 0.
	 */
	virtual pipeline::Value<Solution> retrieveSolution(pipeline::Value<Segments> segments,
													   pipeline::Value<Core> core) = 0;
	
	/**
	 * Print the contents of this store to the DEBUG logging channel.
	 */
	virtual void dumpStore() = 0;
	
private:
	/**
	 * Determine whether the given Segment should be associated to the given Block.
	 */
	bool overlaps(const Segment& segment, const Block& block);

	
};


#endif //SEGMENT_STORE_H__
